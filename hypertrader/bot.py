from __future__ import annotations
import asyncio
import json
import time
import os
import uuid
from pathlib import Path
from datetime import datetime, timezone
from typing import Any, Tuple
from collections.abc import Sequence
from collections import deque
from dataclasses import dataclass, field

import pandas as pd
import numpy as np
from dotenv import load_dotenv

from .config import load_config
from .utils.sentiment import fetch_news_headlines, compute_sentiment_score
from .utils.features import (
    compute_atr,
    onchain_zscore,
    order_skew,
    dom_heatmap_ratio,
    compute_exchange_netflow,
    compute_twap,
    compute_cumulative_delta,
    compute_moving_average,
    compute_ichimoku,
    compute_parabolic_sar,
    compute_keltner_channels,
    compute_cci,
    compute_fibonacci_retracements,
)
from .indicators.microstructure import (
    compute_microprice,
    flow_toxicity,
    detect_iceberg,
    detect_entropy_regime,
)
from .utils.risk import (
    calculate_position_size,
    dynamic_leverage,
    trailing_stop,
    drawdown_throttle,
    kill_switch,
    volatility_scaled_stop,
    ai_var,
    drl_throttle,
    quantum_leverage_modifier,
    cap_position_value,
    fee_slippage_gate,
    compound_capital,
    shap_explain,
)
from .utils.volatility import rank_symbols_by_volatility
from .utils.monitoring import (
    start_metrics_server,
    monitor_latency,
    monitor_equity,
    monitor_var,
    detect_anomalies,
)
from .utils.logging import get_logger, log_json
from .strategies.indicator_signals import generate_signal
from .strategies.ml_strategy import ml_signal, SimpleMLS
from .strategies import (
    MarketMakerStrategy,
    StatisticalArbitrageStrategy,
    TriangularArbitrageStrategy,
    EventTradingStrategy,
    MLStrategy,
    RLStrategy,
    MetaStrategy,
    DonchianBreakout,
    MeanReversionEMA,
    MomentumMultiTF,
    AvellanedaStoikov,
    PairStatArb,
    TriangularArb,
    LatencyArbitrageStrategy,
)
from .binance_bots import (
    SpotGrid,
    FuturesGrid,
    RebalancingBot,
    SpotDCA,
    FundingArbBot,
)
from .allocators import HedgeAllocator

from .data.fetch_data import fetch_ohlcv, fetch_order_book
from .data.oms_store import OMSStore
from .data.onchain import fetch_eth_gas_fees
from .data.macro import (
    fetch_dxy,
    fetch_interest_rate,
    fetch_global_liquidity,
)
from .utils.macro import compute_macro_score
from .execution.ccxt_executor import place_order, cancel_order, ex
from .risk.manager import RiskManager, RiskParams

load_dotenv()


def initialize_all_strategies(symbol: str, config_path: str | None = None) -> dict[str, Any]:
    """Initialize all available trading strategies based on configuration."""
    strategies = {}
    
    # Load configuration
    config = {}
    if config_path:
        try:
            config = load_config(config_path)
        except Exception:
            pass
    
    enabled_strategies = config.get('strategies', {}).get('enabled', [
        'indicator', 'ma_cross', 'rsi', 'bb', 'macd', 'ichimoku', 'psar', 'cci', 'keltner', 'fibonacci', 
        'ml_simple', 'market_maker', 'stat_arb', 'triangular_arb', 'event_trading', 'rl_strategy',
        'spot_grid', 'futures_grid', 'rebalancing', 'spot_dca', 'funding_arb'
    ])
    strategy_params = config.get('strategies', {}).get('parameters', {})
    
    # Technical indicator strategies
    if 'ma_cross' in enabled_strategies:
        params = strategy_params.get('ma_cross', {'fast': 10, 'slow': 30})
        strategies['ma_cross'] = {'type': 'technical', 'params': params}
    
    if 'rsi' in enabled_strategies:
        params = strategy_params.get('rsi', {'period': 14, 'oversold': 30, 'overbought': 70})
        strategies['rsi'] = {'type': 'technical', 'params': params}
    
    if 'bb' in enabled_strategies:
        params = strategy_params.get('bb', {'period': 20, 'std_dev': 2})
        strategies['bb'] = {'type': 'technical', 'params': params}
    
    if 'macd' in enabled_strategies:
        params = strategy_params.get('macd', {'fast': 12, 'slow': 26, 'signal': 9})
        strategies['macd'] = {'type': 'technical', 'params': params}
    
    if 'ichimoku' in enabled_strategies:
        params = strategy_params.get('ichimoku', {})
        strategies['ichimoku'] = {'type': 'technical', 'params': params}
    
    if 'psar' in enabled_strategies:
        params = strategy_params.get('psar', {'step': 0.02, 'max_step': 0.2})
        strategies['psar'] = {'type': 'technical', 'params': params}
    
    if 'cci' in enabled_strategies:
        params = strategy_params.get('cci', {'period': 20})
        strategies['cci'] = {'type': 'technical', 'params': params}
    
    if 'keltner' in enabled_strategies:
        params = strategy_params.get('keltner', {'ema_period': 20, 'atr_period': 10, 'multiplier': 2.0})
        strategies['keltner'] = {'type': 'technical', 'params': params}
    
    if 'fibonacci' in enabled_strategies:
        params = strategy_params.get('fibonacci', {'window': 50})
        strategies['fibonacci'] = {'type': 'technical', 'params': params}
    
    # Advanced strategies
    if 'donchian' in enabled_strategies:
        try:
            strategies['donchian'] = DonchianBreakout(symbol)
        except Exception:
            pass
    
    if 'mean_reversion' in enabled_strategies:
        try:
            strategies['mean_reversion'] = MeanReversionEMA(symbol)
        except Exception:
            pass
    
    if 'momentum' in enabled_strategies:
        try:
            strategies['momentum'] = MomentumMultiTF(symbol)
        except Exception:
            pass
    
    if 'event_trading' in enabled_strategies:
        try:
            strategies['event_trading'] = EventTradingStrategy(symbol)
        except Exception:
            pass
    
    if 'ml_simple' in enabled_strategies:
        try:
            strategies['ml_simple'] = SimpleMLS()
        except Exception:
            pass
    
    # Advanced strategies
    if 'market_maker' in enabled_strategies:
        try:
            strategies['market_maker'] = MarketMakerStrategy(symbol)
        except Exception:
            pass
    
    if 'stat_arb' in enabled_strategies:
        try:
            strategies['stat_arb'] = StatisticalArbitrageStrategy(symbol)
        except Exception:
            pass
    
    if 'triangular_arb' in enabled_strategies:
        try:
            strategies['triangular_arb'] = TriangularArbitrageStrategy(symbol)
        except Exception:
            pass
    
    if 'event_trading' in enabled_strategies:
        try:
            strategies['event_trading'] = EventTradingStrategy(symbol)
        except Exception:
            pass
    
    if 'rl_strategy' in enabled_strategies:
        try:
            strategies['rl_strategy'] = RLStrategy(symbol)
        except Exception:
            pass
    
    # Binance-style bots
    if 'spot_grid' in enabled_strategies:
        try:
            params = strategy_params.get('spot_grid', {'grid_size': 10, 'price_range': 0.1})
            strategies['spot_grid'] = SpotGrid(symbol, **params)
        except Exception:
            pass
    
    if 'futures_grid' in enabled_strategies:
        try:
            params = strategy_params.get('futures_grid', {'grid_size': 10, 'price_range': 0.1})
            strategies['futures_grid'] = FuturesGrid(symbol, **params)
        except Exception:
            pass
    
    if 'rebalancing' in enabled_strategies:
        try:
            params = strategy_params.get('rebalancing', {'target_weights': {}})
            strategies['rebalancing'] = RebalancingBot(**params)
        except Exception:
            pass
    
    if 'spot_dca' in enabled_strategies:
        try:
            params = strategy_params.get('spot_dca', {'interval_hours': 24, 'amount': 100})
            strategies['spot_dca'] = SpotDCA(symbol, **params)
        except Exception:
            pass
    
    if 'funding_arb' in enabled_strategies:
        try:
            params = strategy_params.get('funding_arb', {})
            strategies['funding_arb'] = FundingArbBot(symbol, **params)
        except Exception:
            pass
    
    return strategies


def generate_all_strategy_signals(
    strategies: dict[str, Any], 
    data: pd.DataFrame,
    sentiment: float,
    macro_score: float,
    onchain_score: float,
    book_skew: float,
    heatmap_ratio: float,
    model_path: str | None = None
) -> dict[str, dict[str, Any]]:
    """Generate signals from all strategies."""
    signals = {}
    
    # Original indicator signal
    try:
        sig = generate_signal(data, sentiment, macro_score, onchain_score, book_skew, heatmap_ratio)
        signals['indicator'] = {'action': sig.action, 'confidence': 0.7}
    except Exception:
        signals['indicator'] = {'action': 'HOLD', 'confidence': 0.5}
    
    # Technical strategies
    for name, strategy in strategies.items():
        try:
            if isinstance(strategy, dict) and strategy.get('type') == 'technical':
                action = generate_technical_signal(data, strategy['params'], name)
                signals[name] = {'action': action, 'confidence': 0.6}
            elif hasattr(strategy, 'update'):
                if name == 'ml_simple':
                    result = strategy.update(data)
                    if isinstance(result, tuple):
                        sig, conf, _ = result
                        action = 'BUY' if sig > 0 else 'SELL' if sig < 0 else 'HOLD'
                        signals[name] = {'action': action, 'confidence': conf}
                    else:
                        signals[name] = {'action': 'HOLD', 'confidence': 0.5}
                elif hasattr(strategy, 'on_tick'):
                    # Binance-style bots
                    price = data['close'].iloc[-1]
                    orders = strategy.on_tick(price)
                    if orders and len(orders) > 0:
                        side = orders[0].get('side', 'HOLD')
                        action = 'BUY' if side == 'BUY' else 'SELL' if side == 'SELL' else 'HOLD'
                        signals[name] = {'action': action, 'confidence': 0.6}
                    else:
                        signals[name] = {'action': 'HOLD', 'confidence': 0.5}
                else:
                    # Try price-based update
                    price = data['close'].iloc[-1]
                    if hasattr(strategy, 'update'):
                        orders = strategy.update(price)
                        if orders and len(orders) > 0:
                            side = orders[0][0] if isinstance(orders[0], tuple) else 'HOLD'
                            action = 'BUY' if side == 'buy' else 'SELL' if side == 'sell' else 'HOLD'
                            signals[name] = {'action': action, 'confidence': 0.6}
                        else:
                            signals[name] = {'action': 'HOLD', 'confidence': 0.5}
                    else:
                        signals[name] = {'action': 'HOLD', 'confidence': 0.5}
            else:
                signals[name] = {'action': 'HOLD', 'confidence': 0.5}
        except Exception:
            signals[name] = {'action': 'HOLD', 'confidence': 0.5}
    
    # ML signal if model provided
    if model_path:
        try:
            model = pd.read_pickle(model_path)
            ml_sig = ml_signal(model, data)
            signals['ml_model'] = {'action': ml_sig.action, 'confidence': 0.8}
        except Exception:
            signals['ml_model'] = {'action': 'HOLD', 'confidence': 0.5}
    
    return signals


def generate_technical_signal(data: pd.DataFrame, params: dict, strategy_type: str) -> str:
    """Generate signal from technical indicators."""
    from .indicators.technical import ichimoku, parabolic_sar, cci, keltner_channels, fibonacci_retracements
    
    try:
        if strategy_type == 'ma_cross' and len(data) >= params['slow']:
            fast_ma = data['close'].rolling(params['fast']).mean().iloc[-1]
            slow_ma = data['close'].rolling(params['slow']).mean().iloc[-1]
            return 'BUY' if fast_ma > slow_ma else 'SELL'
        
        elif strategy_type == 'rsi' and len(data) >= params['period']:
            delta = data['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(params['period']).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(params['period']).mean()
            rs = gain / loss.replace(0, 1e-10)  # Avoid division by zero
            rsi = 100 - (100 / (1 + rs))
            current_rsi = rsi.iloc[-1]
            
            if current_rsi < params['oversold']:
                return 'BUY'
            elif current_rsi > params['overbought']:
                return 'SELL'
        
        elif strategy_type == 'bb' and len(data) >= params['period']:
            sma = data['close'].rolling(params['period']).mean()
            std = data['close'].rolling(params['period']).std()
            upper = sma + (std * params['std_dev'])
            lower = sma - (std * params['std_dev'])
            
            current_price = data['close'].iloc[-1]
            if current_price < lower.iloc[-1]:
                return 'BUY'
            elif current_price > upper.iloc[-1]:
                return 'SELL'
        
        elif strategy_type == 'macd' and len(data) >= params['slow']:
            ema_fast = data['close'].ewm(span=params['fast']).mean()
            ema_slow = data['close'].ewm(span=params['slow']).mean()
            macd_line = ema_fast - ema_slow
            signal_line = macd_line.ewm(span=params['signal']).mean()
            
            if macd_line.iloc[-1] > signal_line.iloc[-1] and macd_line.iloc[-2] <= signal_line.iloc[-2]:
                return 'BUY'
            elif macd_line.iloc[-1] < signal_line.iloc[-1] and macd_line.iloc[-2] >= signal_line.iloc[-2]:
                return 'SELL'
        
        # Add new technical strategies
        elif strategy_type == 'ichimoku' and {'high', 'low'}.issubset(data.columns) and len(data) >= 52:
            ichimoku_data = ichimoku(data['high'], data['low'], data['close'])
            tenkan = ichimoku_data['tenkan']
            kijun = ichimoku_data['kijun']
            current_price = data['close'].iloc[-1]
            
            if current_price > tenkan and tenkan > kijun:
                return 'BUY'
            elif current_price < tenkan and tenkan < kijun:
                return 'SELL'
        
        elif strategy_type == 'psar' and {'high', 'low'}.issubset(data.columns) and len(data) >= 10:
            psar_value = parabolic_sar(data['high'], data['low'], params.get('step', 0.02), params.get('max_step', 0.2))
            current_price = data['close'].iloc[-1]
            
            if current_price > psar_value:
                return 'BUY'
            elif current_price < psar_value:
                return 'SELL'
        
        elif strategy_type == 'cci' and {'high', 'low'}.issubset(data.columns) and len(data) >= 20:
            cci_value = cci(data['high'], data['low'], data['close'], params.get('period', 20))
            
            if cci_value < -100:
                return 'BUY'
            elif cci_value > 100:
                return 'SELL'
        
        elif strategy_type == 'keltner' and {'high', 'low'}.issubset(data.columns) and len(data) >= 20:
            kelt = keltner_channels(data['high'], data['low'], data['close'])
            current_price = data['close'].iloc[-1]
            
            if current_price < kelt['lower']:
                return 'BUY'
            elif current_price > kelt['upper']:
                return 'SELL'
        
        elif strategy_type == 'fibonacci' and {'high', 'low'}.issubset(data.columns) and len(data) >= 50:
            fib = fibonacci_retracements(data['high'], data['low'])
            current_price = data['close'].iloc[-1]
            
            if current_price < fib['level_0.382']:
                return 'BUY'
            elif current_price > fib['level_0.618']:
                return 'SELL'
    
    except Exception:
        pass
    
    return 'HOLD'


def update_strategy_performance(
    performance: dict[str, dict], 
    signals: dict[str, dict], 
    data: pd.DataFrame
) -> dict[str, dict]:
    """Update strategy performance tracking."""
    current_return = data['close'].pct_change().iloc[-1] if len(data) > 1 else 0.0
    
    for name, signal_data in signals.items():
        if name not in performance:
            performance[name] = {'returns': [], 'last_signal': 'HOLD', 'confidence': 0.5}
        
        # Calculate return based on previous signal
        prev_signal = performance[name]['last_signal']
        if prev_signal == 'BUY':
            strategy_return = current_return
        elif prev_signal == 'SELL':
            strategy_return = -current_return
        else:
            strategy_return = 0.0
        
        performance[name]['returns'].append(strategy_return)
        performance[name]['last_signal'] = signal_data['action']
        performance[name]['confidence'] = signal_data['confidence']
        
        # Keep only last 100 returns
        if len(performance[name]['returns']) > 100:
            performance[name]['returns'] = performance[name]['returns'][-100:]
    
    return performance


def aggregate_strategy_signals(signals: dict[str, dict], weights: list[float]) -> Any:
    """Aggregate multiple strategy signals using weights."""
    from .strategies.indicator_signals import Signal
    
    if not signals or not weights:
        return Signal('HOLD')
    
    # Calculate weighted votes
    buy_weight = 0.0
    sell_weight = 0.0
    total_weight = 0.0
    
    strategy_names = list(signals.keys())
    for i, (name, signal_data) in enumerate(signals.items()):
        if i < len(weights):
            weight = weights[i] * signal_data['confidence']
            total_weight += weight
            
            if signal_data['action'] == 'BUY':
                buy_weight += weight
            elif signal_data['action'] == 'SELL':
                sell_weight += weight
    
    if total_weight == 0:
        return Signal('HOLD')
    
    # Determine final action based on weighted votes
    buy_ratio = buy_weight / total_weight
    sell_ratio = sell_weight / total_weight
    
    if buy_ratio > 0.6:
        return Signal('BUY')
    elif sell_ratio > 0.6:
        return Signal('SELL')
    else:
        return Signal('HOLD')


@dataclass
class TradingBot:
    """High‑level trading bot orchestrating data, strategies and execution.

    Parameters
    ----------
    connector : ExchangeConnector
        Interface to market data and order execution (live or simulation).
    strategy : object
        Strategy or meta strategy instance that produces orders.
    symbol : str
        Trading pair to operate on.  For multi‑symbol trading,
        instantiate separate bots or extend the class to handle
        multiple symbols.
    base_order_size : float, optional
        Base quantity used when strategies do not specify sizes.
    max_drawdown : float, optional
        Maximum tolerated drawdown expressed as fraction of equity
        (e.g., 0.1 for 10%).  Used by the drawdown throttle.
    stop_loss_pct : float, optional
        Percentage for trailing stop on open positions.  Default is
        0.02 (2%).
    """

    connector: Any
    strategy: Any
    symbol: str
    base_order_size: float = 1.0
    max_drawdown: float = 0.1
    stop_loss_pct: float = 0.02
    # internal state
    equity: float = 0.0
    peak_equity: float = 0.0
    open_position: float = 0.0
    last_price: float = 0.0
    order_history: list[tuple[str, float, float, datetime]] = field(default_factory=list, init=False)

    def update_equity(self, price: float) -> None:
        """Update equity and peak equity based on current price and position."""
        self.last_price = price
        self.equity = self.open_position * price
        self.peak_equity = max(self.peak_equity, self.equity)

    def on_new_tick(self, price: float, trades: list[dict]) -> None:
        """Process a new market tick.

        Parameters
        ----------
        price : float
            Latest trade or mid price of the instrument.
        trades : list of dict
            Recent trades used for toxicity and regime analysis.
        """
        from .utils.features import flow_toxicity, detect_entropy_regime
        from .utils.rl_utils import dynamic_order_size
        
        # Update internal equity
        self.update_equity(price)
        # Compute microstructure signals for RL sizing
        toxicity = flow_toxicity(trades, window=min(len(trades), 100))
        # Determine regime from price directions (use last 20 order history directions)
        directions = [1 if self.order_history[i][1] > 0 else 0 for i in range(max(0, len(self.order_history) - 20), len(self.order_history))] if self.order_history else []
        regime = detect_entropy_regime(directions) if directions else "normal"
        # Generate orders from strategy
        if hasattr(self.strategy, "update"):
            orders = self.strategy.update(price)  # pass price only to simple strategies
        else:
            orders = []
        # Risk checks: trailing stop and drawdown
        # If we have an open position, apply trailing stop
        stop_price = trailing_stop(self.open_position, self.last_price, self.stop_loss_pct)
        if self.open_position > 0 and price < stop_price:
            # Sell to close long position
            orders.append(("sell", price, self.open_position))
            self.open_position = 0.0
        elif self.open_position < 0 and price > stop_price:
            # Buy to close short position
            orders.append(("buy", price, -self.open_position))
            self.open_position = 0.0
        # Drawdown throttle: skip orders if equity falls too far from peak
        if drawdown_throttle(self.equity, self.peak_equity, self.max_drawdown):
            orders = []
        # Process orders
        for side, order_price, qty in orders:
            # Determine dynamic size based on RL sizing
            size = dynamic_order_size(0.6 if side == "buy" else 0.4, toxicity, regime, self.base_order_size)
            # If size or qty is zero, skip
            if size <= 0.0 or qty <= 0.0:
                continue
            # Use price if provided
            exec_price = order_price or price
            # Send order to connector
            self.connector.place_order(self.symbol, side, size, exec_price)
            # Update position
            if side == "buy":
                self.open_position += size
            else:
                self.open_position -= size
            # Record order
            self.order_history.append((side, size, exec_price, datetime.now(timezone.utc)))

async def _run(
    symbol: str | Sequence[str],
    account_balance: float = 100.0,
    risk_percent: float = 5.0,
    news_api_key: str | None = None,
    fred_api_key: str | None = None,
    model_path: str | None = None,
    signal_path: str = "signal.json",
    config_path: str | None = None,
    state_path: str | Path | None = None,
    exchange: str | None = None,
    etherscan_api_key: str | None = None,
    max_exposure: float = 3.0,
    live: bool = False,
    data: pd.DataFrame | None = None,
    store: OMSStore | None = None,
) -> None:
    """Run one iteration of the trading pipeline.

    Parameters
    ----------
    symbol:
        Either a single ticker symbol or a sequence of symbols.  When
        multiple symbols are provided the bot selects the one with the
        highest recent volatility.

    Fetches data, computes sentiment, generates a signal and writes it to JSON.
    """
    if config_path:
        cfg = load_config(config_path)
        symbol = cfg.get("trading", {}).get("symbol", symbol)
        account_balance = cfg.get("trading", {}).get("account_balance", account_balance)
        risk_percent = cfg.get("trading", {}).get("risk_percent", risk_percent)
        exchange = cfg.get("trading", {}).get("exchange", exchange)
        max_exposure = cfg.get("trading", {}).get("max_exposure", max_exposure)
        api_keys = cfg.get("api_keys", {})
        news_api_key = api_keys.get("news", news_api_key)
        fred_api_key = api_keys.get("fred", fred_api_key)
        etherscan_api_key = api_keys.get("etherscan", etherscan_api_key)

    # fall back to environment variables for API keys
    news_api_key = news_api_key or os.getenv("NEWS_API_KEY")
    fred_api_key = fred_api_key or os.getenv("FRED_API_KEY")
    etherscan_api_key = etherscan_api_key or os.getenv("ETHERSCAN_API_KEY")

    # If a sequence of symbols is provided, pick the most volatile one
    if isinstance(symbol, Sequence) and not isinstance(symbol, str):
        try:
            ranked = rank_symbols_by_volatility(symbol)
            symbol = ranked[0] if ranked else list(symbol)[0]
        except Exception:
            # fall back to first symbol if ranking fails
            symbol = list(symbol)[0]

    logger = get_logger()
    start_time = time.time()
    try:
        start_metrics_server()
    except Exception as exc:
        log_json(logger, "metrics_server_failed", error=str(exc))

    # Determine location of persistent risk state
    if state_path is None:
        state_path = Path(signal_path).with_name("state.json")
    state_file = Path(state_path)
    state: dict[str, Any] = {}
    if state_file.exists():
        try:
            state = json.loads(state_file.read_text())
        except json.JSONDecodeError:
            state = {}
    
    # Initialize multi-strategy system
    strategies = initialize_all_strategies(symbol, config_path)
    
    # Load strategy performance history
    strategy_performance = state.get("strategy_performance", {})
    for name in strategies.keys():
        if name not in strategy_performance:
            strategy_performance[name] = {"returns": [], "last_signal": "HOLD", "confidence": 0.5}
    
    latencies = deque(state.get("latencies", []), maxlen=120)
    latency_breach = state.get("latency_breach", 0)
    peak_equity = state.get("peak_equity", account_balance)
    drawdown = (peak_equity - account_balance) / peak_equity if peak_equity > 0 else 0.0
    allocation_factor = drawdown_throttle(account_balance, peak_equity)
    p95_latency = 0.0
    if len(latencies) >= 20:
        p95_latency = float(np.percentile(list(latencies), 95))
        if p95_latency > 2.0:
            latency_breach += 1
        else:
            latency_breach = 0
    latency_soft = latency_breach > 0
    latency_hard = latency_breach >= 3
    if store is None:
        store = OMSStore(state_file.with_suffix(".db"))
        owns_store = True
    else:
        owns_store = False
    open_orders: dict[str, Any] = {
        oid: {"symbol": sym, "side": side, "volume": vol}
        for oid, sym, side, vol, _ in await store.fetch_open_orders()
    }

    risk_cfg = cfg.get("risk", {}) if config_path else {}
    params = RiskParams(
        max_daily_loss=risk_cfg.get("max_daily_loss", account_balance * 0.2),
        max_position=risk_cfg.get("max_position", account_balance * max_exposure),
        fee_rate=risk_cfg.get("fee_rate", 0.0),
        slippage=risk_cfg.get("slippage", 0.0),
        symbol_limits=risk_cfg.get("symbol_limits"),
        max_var=risk_cfg.get("max_var"),
        max_volatility=risk_cfg.get("max_volatility"),
    )
    risk_manager = RiskManager(params)
    risk_manager.reset_day(account_balance)

    ccxt_symbol = symbol.replace('-', '/')

    async def reconcile() -> None:
        try:
            remote_orders = await ex.fetch_open_orders(ccxt_symbol)
        except Exception:
            remote_orders = []
        remote_ids = {o.get("clientOrderId") or o.get("id") for o in remote_orders}
        for oid in list(open_orders):
            if oid not in remote_ids:
                await store.remove_order(oid)
                del open_orders[oid]
        for o in remote_orders:
            cid = o.get("clientOrderId") or o.get("id")
            if cid and cid not in open_orders:
                await store.record_order(
                    cid,
                    o.get("clientOrderId"),
                    o.get("symbol", ccxt_symbol),
                    o.get("side", ""),
                    float(o.get("amount") or o.get("remaining") or 0.0),
                    o.get("price"),
                    o.get("status", "open"),
                    (o.get("timestamp") or 0) / 1000,
                )
                open_orders[cid] = {
                    "symbol": o.get("symbol", ccxt_symbol),
                    "side": o.get("side", ""),
                    "volume": float(o.get("amount") or o.get("remaining") or 0.0),
                }
        try:
            positions = await ex.fetch_positions([ccxt_symbol])
            for p in positions:
                qty = float(
                    p.get("contracts")
                    or p.get("positionAmt")
                    or p.get("size")
                    or 0.0
                )
                if qty:
                    await store.upsert_position(
                        p.get("symbol", ccxt_symbol),
                        qty,
                        float(p.get("entryPrice") or 0.0),
                        float(p.get("liquidationPrice") or 0.0),
                        time.time(),
                    )
        except Exception:
            pass

    # reconcile open orders and positions with the exchange
    if live and exchange:
        await reconcile()
        if time.time() - state.get("last_reconcile", 0) > 300:
            await reconcile()
            state["last_reconcile"] = time.time()

    # cancel any lingering open orders from previous session
    if live and exchange and open_orders:
        for oid, info in list(open_orders.items()):
            try:
                await cancel_order(info["symbol"], oid)
                await store.remove_order(oid)
                del open_orders[oid]
            except Exception as exc:
                log_json(logger, "cancel_failed", order_id=oid, error=str(exc))

    kill = kill_switch(drawdown)
    if kill:
        log_json(logger, "kill_switch_triggered", drawdown=drawdown)
    tasks: list[asyncio.Future] = []
    keys: list[str] = []
    if data is None:
        tasks.append(asyncio.to_thread(fetch_ohlcv, exchange or "binance", ccxt_symbol, "1m"))
        keys.append("data")
    if etherscan_api_key:
        tasks.append(asyncio.to_thread(fetch_eth_gas_fees, etherscan_api_key))
        keys.append("gas")
    if exchange:
        tasks.append(asyncio.to_thread(fetch_order_book, exchange, ccxt_symbol))
        keys.append("order_book")
    if news_api_key:
        tasks.append(asyncio.to_thread(fetch_news_headlines, news_api_key, query=symbol))
        keys.append("news")
    if fred_api_key:
        tasks.append(asyncio.to_thread(fetch_dxy, api_key=fred_api_key))
        keys.append("dxy")
        tasks.append(asyncio.to_thread(fetch_interest_rate, fred_api_key))
        keys.append("rates")
        tasks.append(asyncio.to_thread(fetch_global_liquidity, fred_api_key))
        keys.append("liquidity")

    if tasks:
        results = await asyncio.gather(*tasks, return_exceptions=True)
        result_map = dict(zip(keys, results))
    else:
        result_map = {}

    if data is None:
        data = result_map.get("data")
        if isinstance(data, Exception) or data is None:
            log_json(logger, "data_fetch_failed", symbol=symbol, error=str(data))
            return

    onchain_score = 0.0
    gas_df = result_map.get("gas")
    if isinstance(gas_df, Exception):
        log_json(logger, "onchain_fetch_failed", error=str(gas_df))
    elif gas_df is not None:
        onchain_score = float(onchain_zscore(gas_df).iloc[-1])

    book_skew = 0.0
    heatmap_ratio = 1.0
    order_book = result_map.get("order_book")
    if isinstance(order_book, Exception):
        log_json(logger, "order_book_fetch_failed", error=str(order_book))
    elif order_book is not None:
        book_skew = order_skew(order_book)
        heatmap_ratio = dom_heatmap_ratio(order_book)

    headlines: list[str] = []
    news = result_map.get("news")
    if isinstance(news, Exception):
        log_json(logger, "news_fetch_failed", error=str(news))
    elif news is not None:
        headlines = news
    sentiment = compute_sentiment_score(headlines)

    macro_score = 0.0
    if fred_api_key:
        dxy = result_map.get("dxy")
        rates = result_map.get("rates")
        liquidity = result_map.get("liquidity")
        if any(isinstance(r, Exception) for r in (dxy, rates, liquidity)):
            err = ";".join(str(r) for r in (dxy, rates, liquidity) if isinstance(r, Exception))
            log_json(logger, "macro_fetch_failed", error=err)
        else:
            macro_score = compute_macro_score(dxy, rates, liquidity)

    # Generate signals from all strategies
    strategy_signals = generate_all_strategy_signals(
        strategies, data, sentiment, macro_score, onchain_score, 
        book_skew, heatmap_ratio, model_path
    )
    
    # Update strategy performance tracking
    strategy_performance = update_strategy_performance(
        strategy_performance, strategy_signals, data
    )
    
    # Initialize allocator with correct number of strategies (including indicator signal)
    total_strategies = len(strategy_signals)
    if 'allocator' not in locals() or allocator.n_strategies != total_strategies:
        allocator = HedgeAllocator(total_strategies)
    
    # Calculate strategy weights using allocator
    returns = [perf["returns"][-1] if perf["returns"] else 0.0 
              for perf in strategy_performance.values()]
    
    # Ensure returns list matches allocator size
    if len(returns) != allocator.n_strategies:
        returns = returns[:allocator.n_strategies] + [0.0] * max(0, allocator.n_strategies - len(returns))
    
    allocator.update(returns)
    
    # Aggregate signals using weighted voting
    sig = aggregate_strategy_signals(strategy_signals, allocator.weights)
    
    # Log strategy performance
    log_json(logger, "strategy_signals", 
             signals={name: data['action'] for name, data in strategy_signals.items()},
             weights=allocator.weights[:len(strategy_signals)],
             final_action=sig.action)

    price = data["close"].iloc[-1]
    atr = compute_atr(data).iloc[-1]
    
    # Calculate additional features
    twap = compute_twap(data).iloc[-1] if len(data) > 1 else price
    
    # Exchange net flow (if inflow/outflow data available)
    exchange_flow = 0.0
    if {'inflows', 'outflows'}.issubset(data.columns):
        exchange_flow = compute_exchange_netflow(data).iloc[-1]
    
    # Cumulative delta (if buy/sell volume data available)
    cumulative_delta = 0.0
    if {'buy_vol', 'sell_vol'}.issubset(data.columns):
        cumulative_delta = compute_cumulative_delta(data).iloc[-1]
    
    # Simple moving average for comparison
    sma_20 = compute_moving_average(data['close'], 20).iloc[-1] if len(data) >= 20 else price
    
    # Additional technical indicators for enhanced signal generation
    if {'high', 'low'}.issubset(data.columns) and len(data) >= 52:
        ichimoku_data = compute_ichimoku(data)
        tenkan = ichimoku_data['tenkan'].iloc[-1]
        kijun = ichimoku_data['kijun'].iloc[-1]
        
        psar_value = compute_parabolic_sar(data).iloc[-1]
        
        keltner_data = compute_keltner_channels(data)
        kelt_upper = keltner_data['upper'].iloc[-1]
        kelt_lower = keltner_data['lower'].iloc[-1]
        
        cci_value = compute_cci(data).iloc[-1]
        
        fib_data = compute_fibonacci_retracements(data)
        fib_618 = fib_data['level_0.618'].iloc[-1]
    else:
        tenkan = kijun = psar_value = kelt_upper = kelt_lower = cci_value = fib_618 = 0.0
    
    # Microstructure indicators
    microprice = 0.0
    iceberg_detected = False
    if order_book:
        try:
            microprice = compute_microprice(order_book)
            iceberg_detected = detect_iceberg(order_book)
        except Exception:
            pass
    
    # Flow toxicity and entropy regime (if trade data available)
    toxicity = 0.0
    entropy_regime = "normal"
    if len(data) > 20:
        try:
            # Use price changes as proxy for trade flow
            price_changes = data['close'].diff().dropna().tolist()
            recent_changes = price_changes[-20:] if len(price_changes) >= 20 else price_changes
            directions = [1 if x > 0 else 0 for x in recent_changes]
            entropy_regime = detect_entropy_regime(directions)
            
            # Estimate toxicity from volatility
            if len(price_changes) > 0:
                toxicity = abs(sum(price_changes[-10:])) / len(price_changes[-10:]) if len(price_changes) >= 10 else 0.0
        except Exception:
            pass

    # Estimate recent volatility as std of returns
    volatility = float(data["close"].pct_change().rolling(10).std().iloc[-1])
    if pd.isna(volatility) or volatility <= 0:
        volatility = 0.02
    rl_factor = drl_throttle((drawdown, volatility))
    returns = data["close"].pct_change().dropna().tolist()
    var = ai_var(returns) if returns else 0.0
    allocation_factor *= rl_factor * max(0.1, 1 - var)
    leverage = 0.0
    if not kill:
        leverage = dynamic_leverage(
            account_balance, risk_percent * allocation_factor, volatility
        )
        q_factor = quantum_leverage_modifier([drawdown, volatility])
        leverage *= max(0.1, q_factor)

    if kill:
        sig.action = "HOLD"

    if params.max_var and var > params.max_var:
        sig.action = "HOLD"
    if params.max_volatility and volatility > params.max_volatility:
        sig.action = "HOLD"

    if sig.action == "BUY":
        stop_loss = volatility_scaled_stop(price, vix=volatility * 100, long=True)
        stop_loss = max(stop_loss, trailing_stop(price, price, atr))
        take_profit = price + 4 * atr
    elif sig.action == "SELL":
        stop_loss = volatility_scaled_stop(price, vix=volatility * 100, long=False)
        stop_loss = min(stop_loss, trailing_stop(price, price, atr))
        take_profit = price - 4 * atr
    else:
        stop_loss = None
        take_profit = None

    volume = 0.0
    if stop_loss is not None and not kill:
        volume = calculate_position_size(
            account_balance,
            risk_percent * allocation_factor,
            price,
            stop_loss,
        )
        volume *= leverage
        volume = cap_position_value(volume, price, account_balance, max_exposure)

    payload = {
        "action": sig.action,
        "volume": volume,
        "stop_loss": stop_loss,
        "take_profit": take_profit,
        # use timezone-aware UTC timestamp to avoid deprecation warnings
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "leverage": leverage,
        "var": var,
        "indicators": {
            "atr": float(atr),
            "twap": float(twap),
            "exchange_flow": float(exchange_flow),
            "cumulative_delta": float(cumulative_delta),
            "sma_20": float(sma_20),
            "tenkan": float(tenkan),
            "kijun": float(kijun),
            "psar": float(psar_value),
            "kelt_upper": float(kelt_upper),
            "kelt_lower": float(kelt_lower),
            "cci": float(cci_value),
            "fib_618": float(fib_618),
            "microprice": float(microprice),
            "iceberg_detected": bool(iceberg_detected),
            "toxicity": float(toxicity),
            "entropy_regime": str(entropy_regime),
        },
    }
    position_value = volume * price
    edge = abs((take_profit - price) / price) if take_profit else 0.0
    if latency_hard and live and exchange:
        log_json(logger, "latency_slo_triggered", stage="hard", p95=p95_latency)
        for oid, info in list(open_orders.items()):
            try:
                await cancel_order(info["symbol"], oid)
                await store.update_order_status(oid, "CANCELED")
                del open_orders[oid]
            except Exception:
                pass
        sig.action = "HOLD"
    elif latency_soft and live:
        log_json(logger, "latency_slo_triggered", stage="soft", p95=p95_latency)
        sig.action = "HOLD"
    if live and exchange and sig.action != "HOLD" and volume > 0:
        # Apply fee/slippage gating before order submission
        if fee_slippage_gate(price, price, fee_rate=params.fee_rate, slippage_rate=params.slippage):
            if risk_manager.check_order(account_balance, ccxt_symbol, position_value, edge):
                client_id = uuid.uuid4().hex
                try:
                    order_resp = await place_order(
                        ccxt_symbol, sig.action, volume, client_id=client_id
                    )
                    open_orders[client_id] = {
                        "symbol": ccxt_symbol,
                        "side": sig.action,
                        "volume": volume,
                    }
                    await store.record_order(
                        client_id,
                        client_id,
                        ccxt_symbol,
                        sig.action,
                        volume,
                        order_resp.get("price"),
                        order_resp.get("status", "open"),
                        time.time(),
                    )
                    payload["client_order_id"] = client_id
                except Exception as exc:
                    log_json(logger, "order_failed", error=str(exc))
        else:
            log_json(logger, "risk_check_failed", symbol=symbol, position_value=position_value)

    else:
        Path(signal_path).write_text(json.dumps(payload))
    latency = time.time() - start_time
    monitor_latency(latency)
    monitor_equity(account_balance)
    monitor_var(var)

    latencies.append(latency)
    if len(latencies) > 5:
        labels = detect_anomalies(latencies)
        if labels[-1] == -1:
            log_json(logger, "latency_anomaly", latency=latency)

    log_json(
        logger,
        "signal_generated",
        symbol=symbol,
        action=sig.action,
        price=float(price),
        latency=latency,
        slippage=0.0,
        leverage=leverage,
        drawdown=drawdown,
        var=var,
    )

    # Apply capital compounding
    daily_return = (account_balance - state.get("prev_balance", account_balance)) / account_balance if account_balance > 0 else 0.0
    compounded_balance = compound_capital(account_balance, daily_return)
    
    state["peak_equity"] = max(peak_equity, compounded_balance)
    state["equity"] = compounded_balance
    state["prev_balance"] = account_balance
    state["latencies"] = list(latencies)
    state["latency_breach"] = latency_breach
    state["strategy_performance"] = strategy_performance
    state["allocator_weights"] = allocator.weights
    state_file.write_text(json.dumps(state, default=str))
    if store and owns_store:
        await store.close()


def run(
    symbol: str | Sequence[str],
    account_balance: float = 100.0,
    risk_percent: float = 5.0,
    news_api_key: str | None = None,
    fred_api_key: str | None = None,
    model_path: str | None = None,
    signal_path: str = "signal.json",
    config_path: str | None = None,
    state_path: str | Path | None = None,
    exchange: str | None = None,
    etherscan_api_key: str | None = None,
    max_exposure: float = 3.0,
    live: bool = False,
) -> None:
    """Synchronous wrapper that executes the async trading pipeline."""
    asyncio.run(
        _run(
            symbol,
            account_balance=account_balance,
            risk_percent=risk_percent,
            news_api_key=news_api_key,
            fred_api_key=fred_api_key,
            model_path=model_path,
            signal_path=signal_path,
            config_path=config_path,
            state_path=state_path,
            exchange=exchange,
            etherscan_api_key=etherscan_api_key,
            max_exposure=max_exposure,
            live=live,
        )
    )


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Run autonomous trading bot")
    parser.add_argument(
        "symbol",
        nargs="+",
        help="One or more trading pair symbols e.g. BTC-USD ETH-USD",
    )
    parser.add_argument("--account_balance", type=float, default=100.0)
    parser.add_argument("--risk_percent", type=float, default=5.0)
    parser.add_argument("--news_api_key")
    parser.add_argument("--fred_api_key")
    parser.add_argument("--model_path")

    parser.add_argument("--signal_path", default="signal.json")
    parser.add_argument("--config")
    parser.add_argument("--state_path")
    parser.add_argument("--exchange")
    parser.add_argument("--etherscan_api_key")
    parser.add_argument("--max_exposure", type=float, default=3.0)
    parser.add_argument("--live", action="store_true")
    args = parser.parse_args()

    run(
        args.symbol if len(args.symbol) > 1 else args.symbol[0],
        account_balance=args.account_balance,
        risk_percent=args.risk_percent,
        news_api_key=args.news_api_key,
        fred_api_key=args.fred_api_key,
        model_path=args.model_path,
        signal_path=args.signal_path,
        config_path=args.config,
        state_path=args.state_path,
        exchange=args.exchange,
        etherscan_api_key=args.etherscan_api_key,
        max_exposure=args.max_exposure,
        live=args.live,
    )

